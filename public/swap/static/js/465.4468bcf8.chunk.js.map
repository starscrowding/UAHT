{"version":3,"file":"static/js/465.4468bcf8.chunk.js","mappings":"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","sources":["../node_modules/@uniswap/widgets/node_modules/ajv/lib/ajv.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/codegen/code.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/codegen/index.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/codegen/scope.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/errors.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/index.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/names.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/ref_error.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/resolve.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/rules.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/util.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/validate/applicability.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/validate/boolSchema.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/validate/dataType.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/validate/defaults.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/validate/index.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/validate/keyword.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/compile/validate/subschema.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/core.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/runtime/equal.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/runtime/ucs2length.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/runtime/uri.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/runtime/validation_error.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/allOf.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/anyOf.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/contains.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/dependencies.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/if.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/index.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/items.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/items2020.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/not.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/oneOf.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/properties.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/applicator/thenElse.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/code.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/core/id.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/core/index.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/core/ref.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/discriminator/index.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/discriminator/types.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/draft7.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/format/format.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/format/index.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/metadata.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/validation/const.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/validation/enum.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/validation/index.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/validation/limitItems.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/validation/limitLength.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/validation/limitNumber.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/validation/limitProperties.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/validation/multipleOf.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/validation/pattern.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/validation/required.ts","../node_modules/@uniswap/widgets/node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts","../node_modules/@uniswap/widgets/node_modules/json-schema-traverse/index.js","../node_modules/fast-deep-equal/index.js","../node_modules/uri-js/src/util.ts","../node_modules/uri-js/src/regexps-uri.ts","../node_modules/uri-js/src/regexps-iri.ts","../node_modules/uri-js/node_modules/punycode/punycode.es6.js","../node_modules/uri-js/src/uri.ts","../node_modules/uri-js/src/schemes/http.ts","../node_modules/uri-js/src/schemes/https.ts","../node_modules/uri-js/src/schemes/ws.ts","../node_modules/uri-js/src/schemes/wss.ts","../node_modules/uri-js/src/schemes/mailto.ts","../node_modules/uri-js/src/schemes/urn.ts","../node_modules/uri-js/src/schemes/urn-uuid.ts","../node_modules/uri-js/src/index.ts","../node_modules/@babel/runtime/helpers/asyncToGenerator.js","../node_modules/@babel/runtime/helpers/get.js","../node_modules/@babel/runtime/helpers/superPropBase.js","../node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js"],"sourcesContent":["import type {AnySchemaObject} from \"./types\"\nimport AjvCore from \"./core\"\nimport draft7Vocabularies from \"./vocabularies/draft7\"\nimport discriminator from \"./vocabularies/discriminator\"\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\n\nclass Ajv extends AjvCore {\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n      : draft7MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"\n","export abstract class _CodeOrName {\n  abstract readonly str: string\n  abstract readonly names: UsedNames\n  abstract toString(): string\n  abstract emptyStr(): boolean\n}\n\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\n\nexport class Name extends _CodeOrName {\n  readonly str: string\n  constructor(s: string) {\n    super()\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\n    this.str = s\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    return false\n  }\n\n  get names(): UsedNames {\n    return {[this.str]: 1}\n  }\n}\n\nexport class _Code extends _CodeOrName {\n  readonly _items: readonly CodeItem[]\n  private _str?: string\n  private _names?: UsedNames\n\n  constructor(code: string | readonly CodeItem[]) {\n    super()\n    this._items = typeof code === \"string\" ? [code] : code\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    if (this._items.length > 1) return false\n    const item = this._items[0]\n    return item === \"\" || item === '\"\"'\n  }\n\n  get str(): string {\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\n  }\n\n  get names(): UsedNames {\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\n      return names\n    }, {}))\n  }\n}\n\nexport type CodeItem = Name | string | number | boolean | null\n\nexport type UsedNames = Record<string, number | undefined>\n\nexport type Code = _Code | Name\n\nexport type SafeExpr = Code | number | boolean | null\n\nexport const nil = new _Code(\"\")\n\ntype CodeArg = SafeExpr | string | undefined\n\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\n  const code: CodeItem[] = [strs[0]]\n  let i = 0\n  while (i < args.length) {\n    addCodeArg(code, args[i])\n    code.push(strs[++i])\n  }\n  return new _Code(code)\n}\n\nconst plus = new _Code(\"+\")\n\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\n  const expr: CodeItem[] = [safeStringify(strs[0])]\n  let i = 0\n  while (i < args.length) {\n    expr.push(plus)\n    addCodeArg(expr, args[i])\n    expr.push(plus, safeStringify(strs[++i]))\n  }\n  optimize(expr)\n  return new _Code(expr)\n}\n\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\n  if (arg instanceof _Code) code.push(...arg._items)\n  else if (arg instanceof Name) code.push(arg)\n  else code.push(interpolate(arg))\n}\n\nfunction optimize(expr: CodeItem[]): void {\n  let i = 1\n  while (i < expr.length - 1) {\n    if (expr[i] === plus) {\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\n      if (res !== undefined) {\n        expr.splice(i - 1, 3, res)\n        continue\n      }\n      expr[i++] = \"+\"\n    }\n    i++\n  }\n}\n\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\n  if (b === '\"\"') return a\n  if (a === '\"\"') return b\n  if (typeof a == \"string\") {\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\n    return\n  }\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\n  return\n}\n\nexport function strConcat(c1: Code, c2: Code): Code {\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\n}\n\n// TODO do not allow arrays here\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n    ? x\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\n}\n\nexport function stringify(x: unknown): Code {\n  return new _Code(safeStringify(x))\n}\n\nexport function safeStringify(x: unknown): string {\n  return JSON.stringify(x)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\")\n}\n\nexport function getProperty(key: Code | string | number): Code {\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\n}\n\n//Does best effort to format the name properly\nexport function getEsmExportName(key: Code | string | number): Code {\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\n    return new _Code(`${key}`)\n  }\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\n}\n\nexport function regexpCode(rx: RegExp): Code {\n  return new _Code(rx.toString())\n}\n","import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(private readonly varKind: Name, private readonly name: Name, private rhs?: SafeExpr) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(readonly lhs: Code, public rhs: SafeExpr, private readonly sideEffects?: boolean) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(lhs: Code, private readonly op: Code, rhs: SafeExpr, sideEffects?: boolean) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(private condition: Code | boolean, nodes?: ChildNode[]) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(public name: Name, public args: Code, public async?: boolean) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n","import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n","import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n","import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport * as URI from \"uri-js\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URI.URIComponents,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n","import {Name} from \"./codegen\"\n\nconst names = {\n  // validation function arguments\n  data: new Name(\"data\"), // data passed to validation function\n  // args passed from referencing schema\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n  instancePath: new Name(\"instancePath\"),\n  parentData: new Name(\"parentData\"),\n  parentDataProperty: new Name(\"parentDataProperty\"),\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n  // function scoped variables\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\n  errors: new Name(\"errors\"), // counter of validation errors\n  this: new Name(\"this\"),\n  // \"globals\"\n  self: new Name(\"self\"),\n  scope: new Name(\"scope\"),\n  // JTD serialize/parse name for JSON string and position\n  json: new Name(\"json\"),\n  jsonPos: new Name(\"jsonPos\"),\n  jsonLen: new Name(\"jsonLen\"),\n  jsonPart: new Name(\"jsonPart\"),\n}\n\nexport default names\n","import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\nimport type {UriResolver} from \"../types\"\n\nexport default class MissingRefError extends Error {\n  readonly missingRef: string\n  readonly missingSchema: string\n\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\n    this.missingRef = resolveUrl(resolver, baseId, ref)\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\n  }\n}\n","import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponents} from \"uri-js\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponents): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let baseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = baseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n","import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = typeof _jsonTypes[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n","import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n","import type {AnySchemaObject} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\n\nexport function schemaHasRulesForType(\n  {schema, self}: SchemaObjCxt,\n  type: JSONType\n): boolean | undefined {\n  const group = self.RULES.types[type]\n  return group && group !== true && shouldUseGroup(schema, group)\n}\n\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\n}\n\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\n  return (\n    schema[rule.keyword] !== undefined ||\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\n  )\n}\n","import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\nimport type {SchemaCxt} from \"..\"\nimport {reportError} from \"../errors\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nconst boolError: KeywordErrorDefinition = {\n  message: \"boolean schema is false\",\n}\n\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\n  const {gen, schema, validateName} = it\n  if (schema === false) {\n    falseSchemaError(it, false)\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(N.data)\n  } else {\n    gen.assign(_`${validateName}.errors`, null)\n    gen.return(true)\n  }\n}\n\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\n  const {gen, schema} = it\n  if (schema === false) {\n    gen.var(valid, false) // TODO var\n    falseSchemaError(it)\n  } else {\n    gen.var(valid, true) // TODO var\n  }\n}\n\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\n  const {gen, data} = it\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt: KeywordErrorCxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it,\n  }\n  reportError(cxt, boolError, undefined, overrideAllErrors)\n}\n","import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n","import type {SchemaObjCxt} from \"..\"\nimport {_, getProperty, stringify} from \"../codegen\"\nimport {checkStrictMode} from \"../util\"\n\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\n  const {properties, items} = it.schema\n  if (ty === \"object\" && properties) {\n    for (const key in properties) {\n      assignDefault(it, key, properties[key].default)\n    }\n  } else if (ty === \"array\" && Array.isArray(items)) {\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\n  }\n}\n\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\n  const {gen, compositeRule, data, opts} = it\n  if (defaultValue === undefined) return\n  const childData = _`${data}${getProperty(prop)}`\n  if (compositeRule) {\n    checkStrictMode(it, `default is ignored for: ${childData}`)\n    return\n  }\n\n  let condition = _`${childData} === undefined`\n  if (opts.useDefaults === \"empty\") {\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\n  }\n  // `${childData} === undefined` +\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\n}\n","import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  narrowSchemaTypes(it, types)\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\n  const ts: JSONType[] = []\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t)\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\n  }\n  it.dataTypes = ts\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n","import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n","import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n","export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n","// https://github.com/ajv-validator/ajv/issues/889\nimport * as equal from \"fast-deep-equal\"\n\ntype Equal = typeof equal & {code: string}\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\n\nexport default equal as Equal\n","// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nexport default function ucs2length(str: string): number {\n  const len = str.length\n  let length = 0\n  let pos = 0\n  let value: number\n  while (pos < len) {\n    length++\n    value = str.charCodeAt(pos++)\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos)\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\n    }\n  }\n  return length\n}\n\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\n","import * as uri from \"uri-js\"\n\ntype URI = typeof uri & {code: string}\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\n\nexport default uri as URI\n","import type {ErrorObject} from \"../types\"\n\nexport default class ValidationError extends Error {\n  readonly errors: Partial<ErrorObject>[]\n  readonly ajv: true\n  readonly validation: true\n\n  constructor(errors: Partial<ErrorObject>[]) {\n    super(\"validation failed\")\n    this.errors = errors\n    this.ajv = this.validation = true\n  }\n}\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    const valid = gen.name(\"valid\")\n    schema.forEach((sch: AnySchema, i: number) => {\n      if (alwaysValidSchema(it, sch)) return\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\n      cxt.ok(valid)\n      cxt.mergeEvaluated(schCxt)\n    })\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport {validateUnion} from \"../code\"\n\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  code: validateUnion,\n  error: {message: \"must match a schema in anyOf\"},\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n","import type {ErrorNoParams, Vocabulary} from \"../../types\"\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\nimport prefixItems from \"./prefixItems\"\nimport items from \"./items\"\nimport items2020, {ItemsError} from \"./items2020\"\nimport contains, {ContainsError} from \"./contains\"\nimport dependencies, {DependenciesError} from \"./dependencies\"\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\nimport properties from \"./properties\"\nimport patternProperties from \"./patternProperties\"\nimport notKeyword, {NotKeywordError} from \"./not\"\nimport anyOf, {AnyOfError} from \"./anyOf\"\nimport oneOf, {OneOfError} from \"./oneOf\"\nimport allOf from \"./allOf\"\nimport ifKeyword, {IfKeywordError} from \"./if\"\nimport thenElse from \"./thenElse\"\n\nexport default function getApplicator(draft2020 = false): Vocabulary {\n  const applicator = [\n    // any\n    notKeyword,\n    anyOf,\n    oneOf,\n    allOf,\n    ifKeyword,\n    thenElse,\n    // object\n    propertyNames,\n    additionalProperties,\n    dependencies,\n    properties,\n    patternProperties,\n  ]\n  // array\n  if (draft2020) applicator.push(prefixItems, items2020)\n  else applicator.push(additionalItems, items)\n  applicator.push(contains)\n  return applicator\n}\n\nexport type ApplicatorKeywordError =\n  | ErrorNoParams<\"false schema\">\n  | AdditionalItemsError\n  | ItemsError\n  | ContainsError\n  | AdditionalPropertiesError\n  | DependenciesError\n  | IfKeywordError\n  | AnyOfError\n  | OneOfError\n  | NotKeywordError\n  | PropertyNamesError\n","import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\nimport {validateAdditionalItems} from \"./additionalItems\"\n\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {schema, parentSchema, it} = cxt\n    const {prefixItems} = parentSchema\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\n    else cxt.ok(validateArray(cxt))\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) {\n      cxt.fail()\n      return\n    }\n\n    const valid = gen.name(\"valid\")\n    cxt.subschema(\n      {\n        keyword: \"not\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false,\n      },\n      valid\n    )\n\n    cxt.failResult(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error()\n    )\n  },\n  error: {message: \"must NOT be valid\"},\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {validateTuple} from \"./items\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"prefixItems\",\n  type: \"array\",\n  schemaType: [\"array\"],\n  before: \"uniqueItems\",\n  code: (cxt) => validateTuple(cxt, \"items\"),\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: \"property name must be valid\",\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"propertyNames\",\n  type: \"object\",\n  schemaType: [\"object\", \"boolean\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const valid = gen.name(\"valid\")\n\n    gen.forIn(\"key\", data, (key) => {\n      cxt.setParams({propertyName: key})\n      cxt.subschema(\n        {\n          keyword: \"propertyNames\",\n          data: key,\n          dataTypes: [\"string\"],\n          propertyName: key,\n          compositeRule: true,\n        },\n        valid\n      )\n      gen.if(not(valid), () => {\n        cxt.error(true)\n        if (!it.allErrors) gen.break()\n      })\n    })\n\n    cxt.ok(valid)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"then\", \"else\"],\n  schemaType: [\"object\", \"boolean\"],\n  code({keyword, parentSchema, it}: KeywordCxt) {\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\n  },\n}\n\nexport default def\n","import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n","import type {CodeKeywordDefinition} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\n  },\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport idKeyword from \"./id\"\nimport refKeyword from \"./ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"$id\",\n  \"$defs\",\n  \"$vocabulary\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  idKeyword,\n  refKeyword,\n]\n\nexport default core\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch?.$ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n","import type {ErrorObject} from \"../../types\"\n\nexport enum DiscrError {\n  Tag = \"tag\",\n  Mapping = \"mapping\",\n}\n\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\n  \"discriminator\",\n  {error: E; tag: string; tagValue: unknown},\n  string\n>\n","import type {Vocabulary} from \"../types\"\nimport coreVocabulary from \"./core\"\nimport validationVocabulary from \"./validation\"\nimport getApplicatorVocabulary from \"./applicator\"\nimport formatVocabulary from \"./format\"\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\n\nconst draft7Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationVocabulary,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n  contentVocabulary,\n]\n\nexport default draft7Vocabularies\n","import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport formatKeyword from \"./format\"\n\nconst format: Vocabulary = [formatKeyword]\n\nexport default format\n","import type {Vocabulary} from \"../types\"\n\nexport const metadataVocabulary: Vocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n]\n\nexport const contentVocabulary: Vocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n]\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to constant\",\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"const\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schemaCode, schema} = cxt\n    if ($data || (schema && typeof schema == \"object\")) {\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\n    } else {\n      cxt.fail(_`${schema} !== ${data}`)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n","import type {ErrorObject, Vocabulary} from \"../../types\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\nimport limitLength from \"./limitLength\"\nimport pattern, {PatternError} from \"./pattern\"\nimport limitProperties from \"./limitProperties\"\nimport required, {RequiredError} from \"./required\"\nimport limitItems from \"./limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\nimport constKeyword, {ConstError} from \"./const\"\nimport enumKeyword, {EnumError} from \"./enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} items`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxItems\", \"minItems\"],\n  type: \"array\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport ucs2length from \"../../runtime/ucs2length\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} characters`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxLength\", \"minLength\"],\n  type: \"string\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode, it} = cxt\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\n    const len =\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators, Code} from \"../../compile/codegen\"\n\nconst ops = operators\n\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitNumberError = ErrorObject<\n  Kwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} properties`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxProperties\", \"minProperties\"],\n  type: \"object\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {usePattern} from \"../code\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"pattern\",\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, $data, schema, schemaCode, it} = cxt\n    // TODO regexp should be wrapped in try/catchs\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\n    cxt.fail$data(_`!${regExp}.test(${data})`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n","'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","export function merge(...sets:Array<string>):string {\n\tif (sets.length > 1) {\n\t\tsets[0] = sets[0].slice(0, -1);\n\t\tconst xl = sets.length - 1;\n\t\tfor (let x = 1; x < xl; ++x) {\n\t\t\tsets[x] = sets[x].slice(1, -1);\n\t\t}\n\t\tsets[xl] = sets[xl].slice(1);\n\t\treturn sets.join('');\n\t} else {\n\t\treturn sets[0];\n\t}\n}\n\nexport function subexp(str:string):string {\n\treturn \"(?:\" + str + \")\";\n}\n\nexport function typeOf(o:any):string {\n\treturn o === undefined ? \"undefined\" : (o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase());\n}\n\nexport function toUpperCase(str:string):string {\n\treturn str.toUpperCase();\n}\n\nexport function toArray(obj:any):Array<any> {\n\treturn obj !== undefined && obj !== null ? (obj instanceof Array ? obj : (typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];\n}\n\n\nexport function assign(target: object, source: any): any {\n\tconst obj = target as any;\n\tif (source) {\n\t\tfor (const key in source) {\n\t\t\tobj[key] = source[key];\n\t\t}\n\t}\n\treturn obj;\n}","import { URIRegExps } from \"./uri\";\nimport { merge, subexp } from \"./util\";\n\nexport function buildExps(isIRI:boolean):URIRegExps {\n\tconst\n\t\tALPHA$$ = \"[A-Za-z]\",\n\t\tCR$ = \"[\\\\x0D]\",\n\t\tDIGIT$$ = \"[0-9]\",\n\t\tDQUOTE$$ = \"[\\\\x22]\",\n\t\tHEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),  //case-insensitive\n\t\tLF$$ = \"[\\\\x0A]\",\n\t\tSP$$ = \"[\\\\x20]\",\n\t\tPCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),  //expanded\n\t\tGEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n\t\tSUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n\t\tRESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n\t\tUCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",  //subset, excludes bidi control characters\n\t\tIPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",  //subset\n\t\tUNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n\t\tSCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n\t\tUSERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n\t\tDEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n\t\tDEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),  //relaxed parsing rules\n\t\tIPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n\t\tH16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n\t\tLS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n\t\tIPV6ADDRESS1$ = subexp(                                                            subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n\t\tIPV6ADDRESS2$ = subexp(                                                 \"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n\t\tIPV6ADDRESS3$ = subexp(subexp(                                 H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n\t\tIPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n\t\tIPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n\t\tIPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" +        H16$ + \"\\\\:\"          + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n\t\tIPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\"                                + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n\t\tIPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\"                                + H16$ ), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n\t\tIPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"                                       ), //[ *6( h16 \":\" ) h16 ] \"::\"\n\t\tIPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n\t\tZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),  //RFC 6874\n\t\tIPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),  //RFC 6874\n\t\tIPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),  //RFC 6874, with relaxed parsing rules\n\t\tIPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n\t\tIP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),  //RFC 6874\n\t\tREG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n\t\tHOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n\t\tPORT$ = subexp(DIGIT$$ + \"*\"),\n\t\tAUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n\t\tPCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n\t\tSEGMENT$ = subexp(PCHAR$ + \"*\"),\n\t\tSEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n\t\tSEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n\t\tPATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n\t\tPATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),  //simplified\n\t\tPATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n\t\tPATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tQUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n\t\tFRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n\t\tHIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tURI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tRELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n\t\tRELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tURI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n\t\tABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n\n\t\tGENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tRELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n\t\tSAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tAUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\"\n\t;\n\n\treturn {\n\t\tNOT_SCHEME : new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n\t\tNOT_USERINFO : new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_HOST : new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH : new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH_NOSCHEME : new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_QUERY : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n\t\tNOT_FRAGMENT : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n\t\tESCAPE : new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tUNRESERVED : new RegExp(UNRESERVED$$, \"g\"),\n\t\tOTHER_CHARS : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n\t\tPCT_ENCODED : new RegExp(PCT_ENCODED$, \"g\"),\n\t\tIPV4ADDRESS : new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n\t\tIPV6ADDRESS : new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\")  //RFC 6874, with relaxed parsing rules\n\t};\n}\n\nexport default buildExps(false);\n","import { URIRegExps } from \"./uri\";\nimport { buildExps } from \"./regexps-uri\";\n\nexport default buildExps(true);\n","'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.1.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport default punycode;\n","/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\n\nimport URI_PROTOCOL from \"./regexps-uri\";\nimport IRI_PROTOCOL from \"./regexps-iri\";\nimport punycode from \"punycode\";\nimport { toUpperCase, typeOf, assign } from \"./util\";\n\nexport interface URIComponents {\n\tscheme?:string;\n\tuserinfo?:string;\n\thost?:string;\n\tport?:number|string;\n\tpath?:string;\n\tquery?:string;\n\tfragment?:string;\n\treference?:string;\n\terror?:string;\n}\n\nexport interface URIOptions {\n\tscheme?:string;\n\treference?:string;\n\ttolerant?:boolean;\n\tabsolutePath?:boolean;\n\tiri?:boolean;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n}\n\nexport interface URISchemeHandler<Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents> {\n\tscheme:string;\n\tparse(components:ParentComponents, options:Options):Components;\n\tserialize(components:Components, options:Options):ParentComponents;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n\tabsolutePath?:boolean;\n}\n\nexport interface URIRegExps {\n\tNOT_SCHEME : RegExp,\n\tNOT_USERINFO : RegExp,\n\tNOT_HOST : RegExp,\n\tNOT_PATH : RegExp,\n\tNOT_PATH_NOSCHEME : RegExp,\n\tNOT_QUERY : RegExp,\n\tNOT_FRAGMENT : RegExp,\n\tESCAPE : RegExp,\n\tUNRESERVED : RegExp,\n\tOTHER_CHARS : RegExp,\n\tPCT_ENCODED : RegExp,\n\tIPV4ADDRESS : RegExp,\n\tIPV6ADDRESS : RegExp,\n}\n\nexport const SCHEMES:{[scheme:string]:URISchemeHandler} = {};\n\nexport function pctEncChar(chr:string):string {\n\tconst c = chr.charCodeAt(0);\n\tlet e:string;\n\n\tif (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n\telse if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n\telse if (c < 2048) e = \"%\" + ((c >> 6) | 192).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\telse e = \"%\" + ((c >> 12) | 224).toString(16).toUpperCase() + \"%\" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\n\treturn e;\n}\n\nexport function pctDecChars(str:string):string {\n\tlet newStr = \"\";\n\tlet i = 0;\n\tconst il = str.length;\n\n\twhile (i < il) {\n\t\tconst c = parseInt(str.substr(i + 1, 2), 16);\n\n\t\tif (c < 128) {\n\t\t\tnewStr += String.fromCharCode(c);\n\t\t\ti += 3;\n\t\t}\n\t\telse if (c >= 194 && c < 224) {\n\t\t\tif ((il - i) >= 6) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 6);\n\t\t\t}\n\t\t\ti += 6;\n\t\t}\n\t\telse if (c >= 224) {\n\t\t\tif ((il - i) >= 9) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tconst c3 = parseInt(str.substr(i + 7, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 9);\n\t\t\t}\n\t\t\ti += 9;\n\t\t}\n\t\telse {\n\t\t\tnewStr += str.substr(i, 3);\n\t\t\ti += 3;\n\t\t}\n\t}\n\n\treturn newStr;\n}\n\nfunction _normalizeComponentEncoding(components:URIComponents, protocol:URIRegExps) {\n\tfunction decodeUnreserved(str:string):string {\n\t\tconst decStr = pctDecChars(str);\n\t\treturn (!decStr.match(protocol.UNRESERVED) ? str : decStr);\n\t}\n\n\tif (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n\tif (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\n\treturn components;\n};\n\nfunction _stripLeadingZeros(str:string):string {\n\treturn str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\n\nfunction _normalizeIPv4(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV4ADDRESS) || [];\n\tconst [, address] = matches;\n\t\n\tif (address) {\n\t\treturn address.split(\".\").map(_stripLeadingZeros).join(\".\");\n\t} else {\n\t\treturn host;\n\t}\n}\n\nfunction _normalizeIPv6(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV6ADDRESS) || [];\n\tconst [, address, zone] = matches;\n\n\tif (address) {\n\t\tconst [last, first] = address.toLowerCase().split('::').reverse();\n\t\tconst firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n\t\tconst lastFields = last.split(\":\").map(_stripLeadingZeros);\n\t\tconst isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n\t\tconst fieldCount = isLastFieldIPv4Address ? 7 : 8;\n\t\tconst lastFieldsStart = lastFields.length - fieldCount;\n\t\tconst fields = Array<string>(fieldCount);\n\n\t\tfor (let x = 0; x < fieldCount; ++x) {\n\t\t\tfields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n\t\t}\n\n\t\tif (isLastFieldIPv4Address) {\n\t\t\tfields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n\t\t}\n\n\t\tconst allZeroFields = fields.reduce<Array<{index:number,length:number}>>((acc, field, index) => {\n\t\t\tif (!field || field === \"0\") {\n\t\t\t\tconst lastLongest = acc[acc.length - 1];\n\t\t\t\tif (lastLongest && lastLongest.index + lastLongest.length === index) {\n\t\t\t\t\tlastLongest.length++;\n\t\t\t\t} else {\n\t\t\t\t\tacc.push({ index, length : 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\n\t\tconst longestZeroFields = allZeroFields.sort((a, b) => b.length - a.length)[0];\n\n\t\tlet newHost:string;\n\t\tif (longestZeroFields && longestZeroFields.length > 1) {\n\t\t\tconst newFirst = fields.slice(0, longestZeroFields.index) ;\n\t\t\tconst newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n\t\t\tnewHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n\t\t} else {\n\t\t\tnewHost = fields.join(\":\");\n\t\t}\n\n\t\tif (zone) {\n\t\t\tnewHost += \"%\" + zone;\n\t\t}\n\n\t\treturn newHost;\n\t} else {\n\t\treturn host;\n\t}\n}\n\nconst URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nconst NO_MATCH_IS_UNDEFINED = (<RegExpMatchArray>(\"\").match(/(){0}/))[1] === undefined;\n\nexport function parse(uriString:string, options:URIOptions = {}):URIComponents {\n\tconst components:URIComponents = {};\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\n\tif (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n\n\tconst matches = uriString.match(URI_PARSE);\n\n\tif (matches) {\n\t\tif (NO_MATCH_IS_UNDEFINED) {\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1];\n\t\t\tcomponents.userinfo = matches[3];\n\t\t\tcomponents.host = matches[4];\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = matches[7];\n\t\t\tcomponents.fragment = matches[8];\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = matches[5];\n\t\t\t}\n\t\t} else {  //IE FIX for improper RegExp matching\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1] || undefined;\n\t\t\tcomponents.userinfo = (uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined);\n\t\t\tcomponents.host = (uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined);\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = (uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined);\n\t\t\tcomponents.fragment = (uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined);\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = (uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined);\n\t\t\t}\n\t\t}\n\n\t\tif (components.host) {\n\t\t\t//normalize IP hosts\n\t\t\tcomponents.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n\t\t}\n\n\t\t//determine reference type\n\t\tif (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n\t\t\tcomponents.reference = \"same-document\";\n\t\t} else if (components.scheme === undefined) {\n\t\t\tcomponents.reference = \"relative\";\n\t\t} else if (components.fragment === undefined) {\n\t\t\tcomponents.reference = \"absolute\";\n\t\t} else {\n\t\t\tcomponents.reference = \"uri\";\n\t\t}\n\n\t\t//check for reference errors\n\t\tif (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n\t\t\tcomponents.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n\t\t}\n\n\t\t//find scheme handler\n\t\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t\t//check if scheme can't handle IRIs\n\t\tif (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n\t\t\t//if host component is a domain name\n\t\t\tif (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\tcomponents.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//convert IRI -> URI\n\t\t\t_normalizeComponentEncoding(components, URI_PROTOCOL);\n\t\t} else {\n\t\t\t//normalize encodings\n\t\t\t_normalizeComponentEncoding(components, protocol);\n\t\t}\n\n\t\t//perform scheme specific parsing\n\t\tif (schemeHandler && schemeHandler.parse) {\n\t\t\tschemeHandler.parse(components, options);\n\t\t}\n\t} else {\n\t\tcomponents.error = components.error || \"URI can not be parsed.\";\n\t}\n\n\treturn components;\n};\n\nfunction _recomposeAuthority(components:URIComponents, options:URIOptions):string|undefined {\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\tif (components.userinfo !== undefined) {\n\t\turiTokens.push(components.userinfo);\n\t\turiTokens.push(\"@\");\n\t}\n\n\tif (components.host !== undefined) {\n\t\t//normalize IP hosts, add brackets and escape zone separator for IPv6\n\t\turiTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) => \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\"));\n\t}\n\n\tif (typeof components.port === \"number\" || typeof components.port === \"string\") {\n\t\turiTokens.push(\":\");\n\t\turiTokens.push(String(components.port));\n\t}\n\n\treturn uriTokens.length ? uriTokens.join(\"\") : undefined;\n};\n\nconst RDS1 = /^\\.\\.?\\//;\nconst RDS2 = /^\\/\\.(\\/|$)/;\nconst RDS3 = /^\\/\\.\\.(\\/|$)/;\nconst RDS4 = /^\\.\\.?$/;\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n\nexport function removeDotSegments(input:string):string {\n\tconst output:Array<string> = [];\n\n\twhile (input.length) {\n\t\tif (input.match(RDS1)) {\n\t\t\tinput = input.replace(RDS1, \"\");\n\t\t} else if (input.match(RDS2)) {\n\t\t\tinput = input.replace(RDS2, \"/\");\n\t\t} else if (input.match(RDS3)) {\n\t\t\tinput = input.replace(RDS3, \"/\");\n\t\t\toutput.pop();\n\t\t} else if (input === \".\" || input === \"..\") {\n\t\t\tinput = \"\";\n\t\t} else {\n\t\t\tconst im = input.match(RDS5);\n\t\t\tif (im) {\n\t\t\t\tconst s = im[0];\n\t\t\t\tinput = input.slice(s.length);\n\t\t\t\toutput.push(s);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unexpected dot segment condition\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output.join(\"\");\n};\n\nexport function serialize(components:URIComponents, options:URIOptions = {}):string {\n\tconst protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\t//find scheme handler\n\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t//perform scheme specific serialization\n\tif (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n\n\tif (components.host) {\n\t\t//if host component is an IPv6 address\n\t\tif (protocol.IPV6ADDRESS.test(components.host)) {\n\t\t\t//TODO: normalize IPv6 address as per RFC 5952\n\t\t}\n\n\t\t//if host component is a domain name\n\t\telse if (options.domainHost || (schemeHandler && schemeHandler.domainHost)) {\n\t\t\t//convert IDN via punycode\n\t\t\ttry {\n\t\t\t\tcomponents.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));\n\t\t\t} catch (e) {\n\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//normalize encoding\n\t_normalizeComponentEncoding(components, protocol);\n\n\tif (options.reference !== \"suffix\" && components.scheme) {\n\t\turiTokens.push(components.scheme);\n\t\turiTokens.push(\":\");\n\t}\n\n\tconst authority = _recomposeAuthority(components, options);\n\tif (authority !== undefined) {\n\t\tif (options.reference !== \"suffix\") {\n\t\t\turiTokens.push(\"//\");\n\t\t}\n\n\t\turiTokens.push(authority);\n\n\t\tif (components.path && components.path.charAt(0) !== \"/\") {\n\t\t\turiTokens.push(\"/\");\n\t\t}\n\t}\n\n\tif (components.path !== undefined) {\n\t\tlet s = components.path;\n\n\t\tif (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n\t\t\ts = removeDotSegments(s);\n\t\t}\n\n\t\tif (authority === undefined) {\n\t\t\ts = s.replace(/^\\/\\//, \"/%2F\");  //don't allow the path to start with \"//\"\n\t\t}\n\n\t\turiTokens.push(s);\n\t}\n\n\tif (components.query !== undefined) {\n\t\turiTokens.push(\"?\");\n\t\turiTokens.push(components.query);\n\t}\n\n\tif (components.fragment !== undefined) {\n\t\turiTokens.push(\"#\");\n\t\turiTokens.push(components.fragment);\n\t}\n\n\treturn uriTokens.join(\"\");  //merge tokens into a string\n};\n\nexport function resolveComponents(base:URIComponents, relative:URIComponents, options:URIOptions = {}, skipNormalization?:boolean):URIComponents {\n\tconst target:URIComponents = {};\n\n\tif (!skipNormalization) {\n\t\tbase = parse(serialize(base, options), options);  //normalize base components\n\t\trelative = parse(serialize(relative, options), options);  //normalize relative components\n\t}\n\toptions = options || {};\n\n\tif (!options.tolerant && relative.scheme) {\n\t\ttarget.scheme = relative.scheme;\n\t\t//target.authority = relative.authority;\n\t\ttarget.userinfo = relative.userinfo;\n\t\ttarget.host = relative.host;\n\t\ttarget.port = relative.port;\n\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\ttarget.query = relative.query;\n\t} else {\n\t\tif (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n\t\t\t//target.authority = relative.authority;\n\t\t\ttarget.userinfo = relative.userinfo;\n\t\t\ttarget.host = relative.host;\n\t\t\ttarget.port = relative.port;\n\t\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\t\ttarget.query = relative.query;\n\t\t} else {\n\t\t\tif (!relative.path) {\n\t\t\t\ttarget.path = base.path;\n\t\t\t\tif (relative.query !== undefined) {\n\t\t\t\t\ttarget.query = relative.query;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.query = base.query;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (relative.path.charAt(0) === \"/\") {\n\t\t\t\t\ttarget.path = removeDotSegments(relative.path);\n\t\t\t\t} else {\n\t\t\t\t\tif ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n\t\t\t\t\t\ttarget.path = \"/\" + relative.path;\n\t\t\t\t\t} else if (!base.path) {\n\t\t\t\t\t\ttarget.path = relative.path;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n\t\t\t\t\t}\n\t\t\t\t\ttarget.path = removeDotSegments(target.path);\n\t\t\t\t}\n\t\t\t\ttarget.query = relative.query;\n\t\t\t}\n\t\t\t//target.authority = base.authority;\n\t\t\ttarget.userinfo = base.userinfo;\n\t\t\ttarget.host = base.host;\n\t\t\ttarget.port = base.port;\n\t\t}\n\t\ttarget.scheme = base.scheme;\n\t}\n\n\ttarget.fragment = relative.fragment;\n\n\treturn target;\n};\n\nexport function resolve(baseURI:string, relativeURI:string, options?:URIOptions):string {\n\tconst schemelessOptions = assign({ scheme : 'null' }, options);\n\treturn serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n};\n\nexport function normalize(uri:string, options?:URIOptions):string;\nexport function normalize(uri:URIComponents, options?:URIOptions):URIComponents;\nexport function normalize(uri:any, options?:URIOptions):any {\n\tif (typeof uri === \"string\") {\n\t\turi = serialize(parse(uri, options), options);\n\t} else if (typeOf(uri) === \"object\") {\n\t\turi = parse(serialize(<URIComponents>uri, options), options);\n\t}\n\n\treturn uri;\n};\n\nexport function equal(uriA:string, uriB:string, options?: URIOptions):boolean;\nexport function equal(uriA:URIComponents, uriB:URIComponents, options?:URIOptions):boolean;\nexport function equal(uriA:any, uriB:any, options?:URIOptions):boolean {\n\tif (typeof uriA === \"string\") {\n\t\turiA = serialize(parse(uriA, options), options);\n\t} else if (typeOf(uriA) === \"object\") {\n\t\turiA = serialize(<URIComponents>uriA, options);\n\t}\n\n\tif (typeof uriB === \"string\") {\n\t\turiB = serialize(parse(uriB, options), options);\n\t} else if (typeOf(uriB) === \"object\") {\n\t\turiB = serialize(<URIComponents>uriB, options);\n\t}\n\n\treturn uriA === uriB;\n};\n\nexport function escapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);\n};\n\nexport function unescapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);\n};\n","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"http\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\t//report missing host\n\t\tif (!components.host) {\n\t\t\tcomponents.error = components.error || \"HTTP URIs must have a host.\";\n\t\t}\n\n\t\treturn components;\n\t},\n\n\tserialize : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\tconst secure = String(components.scheme).toLowerCase() === \"https\";\n\n\t\t//normalize the default port\n\t\tif (components.port === (secure ? 443 : 80) || components.port === \"\") {\n\t\t\tcomponents.port = undefined;\n\t\t}\n\t\t\n\t\t//normalize the empty path\n\t\tif (!components.path) {\n\t\t\tcomponents.path = \"/\";\n\t\t}\n\n\t\t//NOTE: We do not parse query strings for HTTP URIs\n\t\t//as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n\t\t//and not the HTTP spec.\n\n\t\treturn components;\n\t}\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport http from \"./http\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"https\",\n\tdomainHost : http.domainHost,\n\tparse : http.parse,\n\tserialize : http.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nexport interface WSComponents extends URIComponents {\n\tresourceName?: string;\n\tsecure?: boolean;\n}\n\nfunction isSecure(wsComponents:WSComponents):boolean {\n\treturn typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n\n//RFC 6455\nconst handler:URISchemeHandler = {\n\tscheme : \"ws\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):WSComponents {\n\t\tconst wsComponents = components as WSComponents;\n\n\t\t//indicate if the secure flag is set\n\t\twsComponents.secure = isSecure(wsComponents);\n\n\t\t//construct resouce name\n\t\twsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n\t\twsComponents.path = undefined;\n\t\twsComponents.query = undefined;\n\n\t\treturn wsComponents;\n\t},\n\n\tserialize : function (wsComponents:WSComponents, options:URIOptions):URIComponents {\n\t\t//normalize the default port\n\t\tif (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n\t\t\twsComponents.port = undefined;\n\t\t}\n\n\t\t//ensure scheme matches secure flag\n\t\tif (typeof wsComponents.secure === 'boolean') {\n\t\t\twsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');\n\t\t\twsComponents.secure = undefined;\n\t\t}\n\n\t\t//reconstruct path from resource name\n\t\tif (wsComponents.resourceName) {\n\t\t\tconst [path, query] = wsComponents.resourceName.split('?');\n\t\t\twsComponents.path = (path && path !== '/' ? path : undefined);\n\t\t\twsComponents.query = query;\n\t\t\twsComponents.resourceName = undefined;\n\t\t}\n\n\t\t//forbid fragment component\n\t\twsComponents.fragment = undefined;\n\n\t\treturn wsComponents;\n\t}\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport ws from \"./ws\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"wss\",\n\tdomainHost : ws.domainHost,\n\tparse : ws.parse,\n\tserialize : ws.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, pctDecChars, unescapeComponent } from \"../uri\";\nimport punycode from \"punycode\";\nimport { merge, subexp, toUpperCase, toArray } from \"../util\";\n\nexport interface MailtoHeaders {\n\t[hfname:string]:string\n}\n\nexport interface MailtoComponents extends URIComponents {\n\tto:Array<string>,\n\theaders?:MailtoHeaders,\n\tsubject?:string,\n\tbody?:string\n}\n\nconst O:MailtoHeaders = {};\nconst isIRI = true;\n\n//RFC 3986\nconst UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nconst HEXDIG$$ = \"[0-9A-Fa-f]\";  //case-insensitive\nconst PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$));  //expanded\n\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nconst ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nconst QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nconst VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nconst DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\");\nconst QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$);\nconst QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$);\nconst QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"');\n\n//RFC 6068\nconst DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\";  //%d33-90 / %d94-126\nconst SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nconst QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$);\nconst DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\");\nconst LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$);\nconst ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$);\nconst TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\");\nconst HFNAME$ = subexp(QCHAR$ + \"*\");\nconst HFVALUE$ = HFNAME$;\nconst HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$);\nconst HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\");\nconst HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$);\nconst MAILTO_URI = new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\");\n\nconst UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nconst PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nconst NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nconst NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\");\nconst NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nconst NOT_HFVALUE = NOT_HFNAME;\nconst TO = new RegExp(\"^\" + TO$ + \"$\");\nconst HFIELDS = new RegExp(\"^\" + HFIELDS2$ + \"$\");\n\nfunction decodeUnreserved(str:string):string {\n\tconst decStr = pctDecChars(str);\n\treturn (!decStr.match(UNRESERVED) ? str : decStr);\n}\n\nconst handler:URISchemeHandler<MailtoComponents> =  {\n\tscheme : \"mailto\",\n\n\tparse : function (components:URIComponents, options:URIOptions):MailtoComponents {\n\t\tconst mailtoComponents = components as MailtoComponents;\n\t\tconst to = mailtoComponents.to = (mailtoComponents.path ? mailtoComponents.path.split(\",\") : []);\n\t\tmailtoComponents.path = undefined;\n\n\t\tif (mailtoComponents.query) {\n\t\t\tlet unknownHeaders = false\n\t\t\tconst headers:MailtoHeaders = {};\n\t\t\tconst hfields = mailtoComponents.query.split(\"&\");\n\n\t\t\tfor (let x = 0, xl = hfields.length; x < xl; ++x) {\n\t\t\t\tconst hfield = hfields[x].split(\"=\");\n\n\t\t\t\tswitch (hfield[0]) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tconst toAddrs = hfield[1].split(\",\");\n\t\t\t\t\t\tfor (let x = 0, xl = toAddrs.length; x < xl; ++x) {\n\t\t\t\t\t\t\tto.push(toAddrs[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"subject\":\n\t\t\t\t\t\tmailtoComponents.subject = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"body\":\n\t\t\t\t\t\tmailtoComponents.body = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tunknownHeaders = true;\n\t\t\t\t\t\theaders[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (unknownHeaders) mailtoComponents.headers = headers;\n\t\t}\n\n\t\tmailtoComponents.query = undefined;\n\n\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\tconst addr = to[x].split(\"@\");\n\n\t\t\taddr[0] = unescapeComponent(addr[0]);\n\n\t\t\tif (!options.unicodeSupport) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\taddr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tmailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr[1] = unescapeComponent(addr[1], options).toLowerCase();\n\t\t\t}\n\n\t\t\tto[x] = addr.join(\"@\");\n\t\t}\n\n\t\treturn mailtoComponents;\n\t},\n\n\tserialize : function (mailtoComponents:MailtoComponents, options:URIOptions):URIComponents {\n\t\tconst components = mailtoComponents as URIComponents;\n\t\tconst to = toArray(mailtoComponents.to);\n\t\tif (to) {\n\t\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\t\tconst toAddr = String(to[x]);\n\t\t\t\tconst atIdx = toAddr.lastIndexOf(\"@\");\n\t\t\t\tconst localPart = (toAddr.slice(0, atIdx)).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n\t\t\t\tlet domain = toAddr.slice(atIdx + 1);\n\n\t\t\t\t//convert IDN via punycode\n\t\t\t\ttry {\n\t\t\t\t\tdomain = (!options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t\t}\n\n\t\t\t\tto[x] = localPart + \"@\" + domain;\n\t\t\t}\n\n\t\t\tcomponents.path = to.join(\",\");\n\t\t}\n\n\t\tconst headers = mailtoComponents.headers = mailtoComponents.headers || {};\n\n\t\tif (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n\t\tif (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n\n\t\tconst fields = [];\n\t\tfor (const name in headers) {\n\t\t\tif (headers[name] !== O[name]) {\n\t\t\t\tfields.push(\n\t\t\t\t\tname.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) +\n\t\t\t\t\t\"=\" +\n\t\t\t\t\theaders[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (fields.length) {\n\t\t\tcomponents.query = fields.join(\"&\");\n\t\t}\n\n\t\treturn components;\n\t}\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, SCHEMES } from \"../uri\";\n\nexport interface URNComponents extends URIComponents {\n\tnid?:string;\n\tnss?:string;\n}\n\nexport interface URNOptions extends URIOptions {\n\tnid?:string;\n}\n\nconst NID$ = \"(?:[0-9A-Za-z][0-9A-Za-z\\\\-]{1,31})\";\nconst PCT_ENCODED$ = \"(?:\\\\%[0-9A-Fa-f]{2})\";\nconst TRANS$$ = \"[0-9A-Za-z\\\\(\\\\)\\\\+\\\\,\\\\-\\\\.\\\\:\\\\=\\\\@\\\\;\\\\$\\\\_\\\\!\\\\*\\\\'\\\\/\\\\?\\\\#]\";\nconst NSS$ = \"(?:(?:\" + PCT_ENCODED$ + \"|\" + TRANS$$ + \")+)\";\nconst URN_SCHEME = new RegExp(\"^urn\\\\:(\" + NID$ + \")$\");\nconst URN_PATH = new RegExp(\"^(\" + NID$ + \")\\\\:(\" + NSS$ + \")$\");\nconst URN_PARSE = /^([^\\:]+)\\:(.*)/;\nconst URN_EXCLUDED = /[\\x00-\\x20\\\\\\\"\\&\\<\\>\\[\\]\\^\\`\\{\\|\\}\\~\\x7F-\\xFF]/g;\n\n//RFC 2141\nconst handler:URISchemeHandler<URNComponents,URNOptions> = {\n\tscheme : \"urn\",\n\n\tparse : function (components:URIComponents, options:URNOptions):URNComponents {\n\t\tconst matches = components.path && components.path.match(URN_PARSE);\n\t\tlet urnComponents = components as URNComponents;\n\n\t\tif (matches) {\n\t\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\t\tconst nid = matches[1].toLowerCase();\n\t\t\tconst nss = matches[2];\n\t\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\t\turnComponents.nid = nid;\n\t\t\turnComponents.nss = nss;\n\t\t\turnComponents.path = undefined;\n\n\t\t\tif (schemeHandler) {\n\t\t\t\turnComponents = schemeHandler.parse(urnComponents, options) as URNComponents;\n\t\t\t}\n\t\t} else {\n\t\t\turnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n\t\t}\n\n\t\treturn urnComponents;\n\t},\n\n\tserialize : function (urnComponents:URNComponents, options:URNOptions):URIComponents {\n\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\tconst nid = urnComponents.nid;\n\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\tif (schemeHandler) {\n\t\t\turnComponents = schemeHandler.serialize(urnComponents, options) as URNComponents;\n\t\t}\n\n\t\tconst uriComponents = urnComponents as URIComponents;\n\t\tconst nss = urnComponents.nss;\n\t\turiComponents.path = `${nid || options.nid}:${nss}`;\n\n\t\treturn uriComponents;\n\t},\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { URNComponents } from \"./urn\";\nimport { SCHEMES } from \"../uri\";\n\nexport interface UUIDComponents extends URNComponents {\n\tuuid?: string;\n}\n\nconst UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\nconst UUID_PARSE = /^[0-9A-Fa-f\\-]{36}/;\n\n//RFC 4122\nconst handler:URISchemeHandler<UUIDComponents, URIOptions, URNComponents> = {\n\tscheme : \"urn:uuid\",\n\n\tparse : function (urnComponents:URNComponents, options:URIOptions):UUIDComponents {\n\t\tconst uuidComponents = urnComponents as UUIDComponents;\n\t\tuuidComponents.uuid = uuidComponents.nss;\n\t\tuuidComponents.nss = undefined;\n\n\t\tif (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n\t\t\tuuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n\t\t}\n\n\t\treturn uuidComponents;\n\t},\n\n\tserialize : function (uuidComponents:UUIDComponents, options:URIOptions):URNComponents {\n\t\tconst urnComponents = uuidComponents as URNComponents;\n\t\t//normalize UUID\n\t\turnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n\t\treturn urnComponents;\n\t},\n};\n\nexport default handler;","import { SCHEMES } from \"./uri\";\n\nimport http from \"./schemes/http\";\nSCHEMES[http.scheme] = http;\n\nimport https from \"./schemes/https\";\nSCHEMES[https.scheme] = https;\n\nimport ws from \"./schemes/ws\";\nSCHEMES[ws.scheme] = ws;\n\nimport wss from \"./schemes/wss\";\nSCHEMES[wss.scheme] = wss;\n\nimport mailto from \"./schemes/mailto\";\nSCHEMES[mailto.scheme] = mailto;\n\nimport urn from \"./schemes/urn\";\nSCHEMES[urn.scheme] = urn;\n\nimport uuid from \"./schemes/urn-uuid\";\nSCHEMES[uuid.scheme] = uuid;\n\nexport * from \"./uri\";\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nmodule.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var superPropBase = require(\"./superPropBase.js\");\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    module.exports = _get = Reflect.get.bind(), module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  } else {\n    module.exports = _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  }\n  return _get.apply(this, arguments);\n}\nmodule.exports = _get, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var getPrototypeOf = require(\"./getPrototypeOf.js\");\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\nmodule.exports = _superPropBase, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\nmodule.exports = _taggedTemplateLiteral, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"],"names":["META_SUPPORT_DATA","META_SCHEMA_ID","Ajv","draft7_1","forEach","v","addVocabulary","this","opts","discriminator","addKeyword","discriminator_1","meta","metaSchema","$data","$dataMetaSchema","draft7MetaSchema","addMetaSchema","refs","defaultMeta","getSchema","undefined","core_1","module","exports","Object","defineProperty","value","enumerable","get","KeywordCxt","_","str","stringify","nil","Name","CodeGen","default","_CodeOrName","s","test","Error","_Code","code","_items","length","item","_str","reduce","c","_names","names","strs","i","args","addCodeArg","push","plus","expr","safeStringify","res","mergeExprItems","splice","optimize","arg","x","Array","isArray","join","a","b","slice","JSON","replace","c1","c2","emptyStr","key","rx","toString","strConcat","getProperty","regexpCode","Scope","ValueScope","ValueScopeName","varKinds","GT","code_1","GTE","LT","LTE","EQ","NEQ","NOT","OR","AND","ADD","Node","_constants","Def","varKind","name","rhs","es5","_n","scope_1","var","constants","optimizeExpr","Assign","lhs","sideEffects","addExprNames","AssignOp","op","Label","label","Break","Throw","error","AnyCode","ParentNode","nodes","n","render","optimizeNodes","optimizeNames","subtractNames","addNames","BlockNode","Root","Else","If","condition","else","cond","e","ns","not","For","ForLoop","iteration","ForRange","from","to","ForIter","loop","iterable","Func","async","_async","Return","Try","catch","finally","Catch","Finally","extScope","_values","_blockStarts","lines","_extScope","_scope","parent","_nodes","_root","prefix","prefixOrName","Set","add","keyOrRef","getValue","scopeName","scopeRefs","scopeCode","nameOrPrefix","constant","toName","_leafNode","_constant","_def","const","let","keyValues","thenBody","elseBody","_blockNode","endIf","_elseNode","_endBlockNode","node","forBody","endFor","_for","arr","forRange","obj","ownProperties","forOf","tryBody","catchCode","finallyCode","_currNode","body","nodeCount","endBlock","len","pop","toClose","funcBody","endFunc","N1","N2","kind","replaceName","some","items","par","andCode","mappend","orCode","y","UsedValueState","ValueError","prefixes","_prefixes","_parent","_newName","ng","_nameGroup","index","has","nameStr","property","itemIndex","scopePath","line","scope","ref","valueKey","vs","_name","Map","set","setValue","values","_reduceValues","usedValues","getCode","valueCode","nameSet","Started","def","Completed","addError","gen","errObj","err","if","names_1","vErrors","assign","errors","returnErrors","it","errs","validateName","schemaEnv","$async","throw","ValidationError","return","message","keyword","schemaType","cxt","errorPaths","overrideAllErrors","compositeRule","allErrors","errorObjectCode","errsCount","schemaValue","data","instancePath","errorPath","errSchemaPath","verbose","E","codegen_1","schemaPath","params","propertyName","schema","parentSchema","createErrors","errorInstancePath","errorSchemaPath","topSchemaRef","messages","extraErrorProps","object","errorObject","instPath","getErrorPath","util_1","Str","schPath","SchemaEnv","env","dynamicAnchors","schemaId","root","baseId","normalizeId","localRefs","compileSchema","sch","_sch","getCompilingSchema","call","_ValidationError","rootId","getFullPath","uriResolver","scopeValue","validation_error_1","sourceCode","schemaCxt","parentData","parentDataProperty","dataNames","dataPathArr","dataLevel","dataTypes","definedProperties","source","jtd","self","_compilations","validateFunctionCode","validateCode","process","validate","Function","makeValidate","scopeValues","unevaluated","props","evaluated","dynamicProps","dynamicItems","logger","delete","inlineOrCompile","inlineRef","inlineRefs","schEnv","s1","s2","resolve","schemas","resolveSchema","p","parse","refPath","_getFullPath","keys","getJsonPointer","id","schOrRef","schId","resolveUrl","schOrFunc","PREVENT_SCOPE_CHANGE","parsedRef","fragment","split","part","partSchema","unescapeFragment","$ref","schemaHasRulesButRef","RULES","valCxt","rootData","json","jsonPos","jsonLen","jsonPart","MissingRefError","resolver","msg","missingRef","missingSchema","SIMPLE_INLINED","limit","hasRef","countKeys","REF_KEYWORDS","count","Infinity","eachItem","serialize","TRAILING_SLASH_HASH","ANCHOR","baseIds","pathPrefix","schemaRefs","traverse","allKeys","jsonPtr","parentJsonPtr","fullPath","addRef","addAnchor","$anchor","$dynamicAnchor","_resolve","ambiguos","checkAmbiguosRef","anchor","sch1","sch2","equal","jsonTypes","groups","number","type","rules","string","array","types","integer","boolean","null","post","all","keywords","checkUnknownRules","strictSchema","checkStrictMode","schemaHasRules","escapeJsonPointer","unescapeJsonPointer","makeMergeEvaluated","mergeNames","mergeToName","mergeValues","resultToName","evaluatedPropsToName","ps","setEvaluated","hash","decodeURIComponent","encodeURIComponent","xs","f","Math","max","Type","snippets","mode","warn","dataProp","dataPropType","jsPropertySyntax","isNumber","Num","shouldUseGroup","group","rule","shouldUseRule","definition","implements","kwd","boolError","falseSchemaError","schemaCode","reportError","valid","DataType","getJSONTypes","ts","every","rules_1","includes","nullable","coerceTo","coerceTypes","filter","t","COERCIBLE","coerceToTypes","checkTypes","schemaHasRulesForType","wrongType","checkDataTypes","strictNumbers","Wrong","dataType","coerced","coerceSpecificType","elseIf","reportTypeError","assignParentData","coerceData","checkDataType","strictNums","correct","Correct","numCond","_cond","and","toHash","notObj","typeError","schemaRefOrVal","getTypeErrorContext","assignDefault","prop","defaultValue","childData","useDefaults","ty","properties","validateFunction","func","funcSourceUrl","dynamicRef","destructureValCxtES5","destructureValCxt","subschemaCode","isSchemaObj","checkKeywords","schemaCxtHasRules","$comment","commentKeyword","updateContext","checkAsyncSchema","typeAndKeywords","subSchemaObjCode","boolOrEmptySchema","ignoreKeywordsWithRef","checkRefsAndKeywords","schemaKeywords","getSchemaTypes","coerceAndCheckDataType","rootName","typeErrors","groupKeywords","iterateKeywords","strictTypes","includesType","strictTypesError","withTypes","narrowSchemaTypes","checkContextTypes","allowUnionTypes","checkMultipleTypes","hasApplicableType","checkKeywordTypes","checkStrictTypes","block","keywordCode","assignDefaults","schTs","kwdT","checkNoDefault","resetEvaluated","assignEvaluated","returnResults","topSchemaObjCode","topBoolOrEmptySchema","validateKeywordUsage","getData","validSchemaType","allowUndefined","trackErrors","successAction","failAction","failResult","fail","or","invalid$data","append","errorParams","setParams","_error","errors_1","$dataError","resetErrorsCount","codeBlock","$dataValid","check$data","validateSchema","st","dataType_2","wrong$DataType","validateSchemaRef","invalid$DataSchema","appl","subschema","getSubschema","extendSubschemaData","extendSubschemaMode","nextContext","mergeEvaluated","ruleType","funcKeywordCode","macroKeywordCode","compile","JSON_POINTER","RELATIVE_JSON_POINTER","jsonPointer","matches","exec","up","errorMsg","segments","segment","pointerType","modifyData","useKeyword","result","macroSchema","macro","schemaRef","pass","checkAsyncKeyword","validateRef","assignValid","_await","passCxt","passContext","passSchema","callValidateCode","modifying","reportErrs","block$data","ruleErrs","try","validateAsync","validateErrs","validateSync","extendErrors","addErrs","ok","deps","dependencies","prototype","hasOwnProperty","errorsText","schemaProp","escapeFragment","dpType","dataContextProps","_nextData","jtdDiscriminator","jtdMetadata","defaultRegExp","flags","RegExp","META_IGNORE_OPTIONS","EXT_SCOPE_NAMES","removedOptions","errorDataPath","format","jsonPointers","extendRefs","missingRefs","processCode","strictDefaults","strictKeywords","uniqueItems","unknownFormats","cache","ajvErrors","deprecatedOptions","unicode","formats","_loading","_cache","o","strict","_optz","regExp","uri_1","strictTuples","strictRequired","loopRequired","loopEnum","addUsedSchema","validateFormats","unicodeRegExp","int32range","requiredOptions","codegen_2","noLogs","console","log","getLogger","formatOpt","getRules","checkOptions","_metaOpts","getMetaSchemaOptions","addInitialFormats","_addVocabularies","_addDefaultMetaSchema","addInitialKeywords","addInitialSchemas","_dataRefSchema","$dataRefSchema","$id","schemaKeyRef","_meta","_addSchema","_compileSchemaEnv","loadSchema","runCompileAsync","_schema","loadMetaSchema","$schema","_compileAsync","ref_error_1","checkLoaded","loadMissingSchema","_loadSchema","addSchema","_validateSchema","_checkUnique","throwOrLogError","keyRef","getSchEnv","compile_1","_removeAllSchemas","clear","cacheKey","definitions","kwdOrDef","checkKeyword","addRule","keywordMetaschema","k","findIndex","separator","dataVar","map","text","keywordsJsonPointers","schemaOrData","regex","resolve_1","startsWith","_compileMetaSchema","currentOpts","checkOpts","options","opt","optsSchemas","addFormat","defs","metaOpts","KEYWORD_NAME","ruleGroup","find","before","addBeforeRule","_rule","$dataRef","anyOf","ucs2length","pos","charCodeAt","uri","ajv","validation","validateAdditionalItems","alwaysValidSchema","break","validateItems","additionalProperty","removeAdditional","allSchemaProperties","patProps","patternProperties","forIn","definedProp","propsSchema","isOwnProperty","usePattern","isAdditional","additionalPropertyCode","deleteAdditional","applyAdditionalSchema","reset","schCxt","min","minContains","maxContains","next","validateItemsWithCount","schValid","checkLimits","_valid","depsCount","property_ies","missingProperty","propertyDeps","schemaDeps","splitDependencies","propDeps","schDeps","validatePropertyDeps","validateSchemaDeps","missing","hasProperty","propertyInData","depProp","checkReportMissingProp","checkMissingProp","reportMissingProp","mergeValidEvaluated","ifClause","then","hasThen","hasSchema","hasElse","validateIf","validateClause","draft2020","applicator","not_1","anyOf_1","oneOf_1","allOf_1","if_1","thenElse_1","propertyNames_1","additionalProperties_1","dependencies_1","properties_1","patternProperties_1","prefixItems_1","items2020_1","additionalItems_1","items_1","contains_1","validateTuple","validateArray","extraItems","schArr","l","fullTuple","minItems","maxItems","checkStrictTuple","prefixItems","passing","patterns","alwaysValidPatterns","checkProperties","allowMatchingProperties","pat","checkMatchingProperties","validateProperties","validatePatternProperties","alwaysValid","util_2","additionalProperties","validate_1","allProps","hasDefault","applyPropertySchema","hasPropFunc","noPropertyInData","schemaMap","context","dataAndSchema","newRegExp","pattern","u","useFunc","validArr","notValid","core","id_1","ref_1","callRef","callRootRef","schOrEnv","getValidate","callValidate","schName","inlineRefSchema","addErrorsFrom","addEvaluatedFrom","schEvaluated","callAsyncRef","discrError","tagName","types_1","Tag","tag","oneOf","mapping","applyTagSchema","oneOfMapping","topRequired","hasRequired","tagRequired","propSch","addMappings","required","addMapping","enum","tagValue","getMapping","Mapping","validateMapping","DiscrError","draft7Vocabularies","validation_1","format_1","metadata_1","fmts","fDef","fType","fail$data","callFormat","validData","invalidFmt","validate$DataFormat","formatDef","unknownMsg","unknownFormat","fmtDef","fmt","getFormat","fmtType","fmtRef","validCondition","validateFormat","equal_1","eql","useLoop","getEql","vSchema","_x","equalCode","limitNumber_1","multipleOf_1","limitLength_1","pattern_1","limitProperties_1","required_1","limitItems_1","uniqueItems_1","const_1","enum_1","comp","ucs2length_1","ops","KWDs","maximum","okStr","minimum","exclusiveMaximum","exclusiveMinimum","prec","multipleOfPrecision","invalid","loopAllRequired","allErrorsMode","loopUntilMissing","exitOnErrorMode","requiredKey","j","itemTypes","loopN","loopN2","dataType_1","indices","for","outer","cb","_traverse","pre","rootSchema","parentKeyword","keyIndex","arrayKeywords","propsKeywords","skipKeywords","additionalItems","contains","propertyNames","allOf","$defs","multipleOf","maxLength","minLength","maxProperties","minProperties","constructor","valueOf","sets","xl","shift","toLowerCase","toUpperCase","setInterval","target","isIRI","ALPHA$$","DIGIT$$","HEXDIG$$","merge","PCT_ENCODED$","subexp","SUB_DELIMS$$","RESERVED$$","SCHEME$","USERINFO$","UNRESERVED$$","DEC_OCTET_RELAXED$","H16$","LS32$","IPV4ADDRESS$","IPV6ADDRESS1$","IPV6ADDRESS2$","IPV6ADDRESS3$","IPV6ADDRESS4$","IPV6ADDRESS5$","IPV6ADDRESS6$","IPV6ADDRESS7$","IPV6ADDRESS8$","IPV6ADDRESS9$","ZONEID$","IPV6ADDRESS$","IP_LITERAL$","IPV6ADDRZ_RELAXED$","IPVFUTURE$","HOST$","REG_NAME$","PORT$","AUTHORITY$","PCHAR$","SEGMENT$","SEGMENT_NZ$","SEGMENT_NZ_NC$","PATH_ABEMPTY$","PATH_ABSOLUTE$","QUERY$","PATH_NOSCHEME$","PATH_ROOTLESS$","PATH_EMPTY$","IPRIVATE$$","FRAGMENT$","HIER_PART$","URI$","RELATIVE_PART$","RELATIVE$","buildExps","maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","baseMinusTMin","floor","stringFromCharCode","String","fromCharCode","RangeError","fn","mapDomain","parts","ucs2decode","output","counter","extra","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","decode","input","inputLength","bias","basic","lastIndexOf","oldi","w","baseMinusT","out","fromCodePoint","encode","currentValue","basicLength","handledCPCount","m","handledCPCountPlusOne","q","qMinusT","toUnicode","toASCII","punycode","SCHEMES","chr","newStr","il","parseInt","substr","c3","_normalizeComponentEncoding","components","protocol","decodeUnreserved","decStr","pctDecChars","match","UNRESERVED","scheme","PCT_ENCODED","NOT_SCHEME","userinfo","NOT_USERINFO","pctEncChar","host","NOT_HOST","path","NOT_PATH","NOT_PATH_NOSCHEME","query","NOT_QUERY","NOT_FRAGMENT","_stripLeadingZeros","_normalizeIPv4","IPV4ADDRESS","address","_normalizeIPv6","IPV6ADDRESS","zone","reverse","last","first","firstFields","lastFields","isLastFieldIPv4Address","fieldCount","lastFieldsStart","fields","longestZeroFields","acc","field","lastLongest","sort","newHost","newFirst","newLast","URI_PARSE","NO_MATCH_IS_UNDEFINED","uriString","iri","IRI_PROTOCOL","URI_PROTOCOL","reference","port","isNaN","indexOf","schemeHandler","unicodeSupport","domainHost","_recomposeAuthority","uriTokens","$1","$2","RDS1","RDS2","RDS3","RDS5","im","authority","charAt","absolutePath","removeDotSegments","relative","tolerant","baseURI","relativeURI","schemelessOptions","resolveComponents","typeOf","uriA","uriB","ESCAPE","handler","secure","http","isSecure","wsComponents","resourceName","ws","O","ATEXT$$","VCHAR$$","SOME_DELIMS$$","NOT_LOCAL_PART","NOT_HFNAME","NOT_HFVALUE","mailtoComponents","unknownHeaders","headers","hfields","hfield","toAddrs","subject","unescapeComponent","addr","toArray","toAddr","atIdx","localPart","domain","URN_PARSE","urnComponents","nid","nss","urnScheme","uriComponents","UUID","uuidComponents","uuid","https","wss","mailto","urn","asyncGeneratorStep","reject","_next","_throw","info","done","Promise","arguments","apply","__esModule","superPropBase","_get","Reflect","bind","receiver","desc","getOwnPropertyDescriptor","getPrototypeOf","strings","raw","freeze","defineProperties"],"sourceRoot":""}